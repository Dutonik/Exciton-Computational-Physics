#include <sys/stat.h>
#include <cstdio>
#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <ctime>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <random>
#include <algorithm>

//THIS CODE REQUIRES C++11
//Time not synced properly for real modelling this is for testing purposes

class Exciton{
public:
    std::string name;
    int X_pos;
    int Y_pos;
    bool active;
    int decayX;
    int decayY;
    std::string fate;
    int decayTime;
    double expectation_x_term1; //for <x^2>
    double expectation_x_term2; //for <x>^2
    double expectation_y_term1; //for <y^2>
    double expectation_y_term2; //for <y>^2
    

    Exciton(int X_pos, int Y_pos, bool active, std::string name){
        this->X_pos = X_pos;
        this->Y_pos = Y_pos;
        this->active = active;
        this->name = name;
        decayTime=0;
    }
};

//GLOBAL
using std::cout;
using std::endl;
using std::string;
using std::vector;

//Global strain attraction parameter
const double K_sA = 10;

//Define the active exciton list. This is what will keep track of the "living" exciton population
vector<Exciton> active_Excitons;

//Set spawn seet for exciton spawning (we only need 1 seed for the spawn gaussian each time we run the program so I put it in global)
std::random_device rd;
std::mt19937 rng(rd());
std::uniform_real_distribution<double> uni(0,1);

//Nx and Ny determine the size of the grid
const int Nx = 100;
const int Ny = 100;

//define the cell struct to store x and y points which we will access like ordered pairs
struct cell{
    int x;
    int y;
    //Is this tile strained (set strained tiles manually)
    bool strained;
    double P_left;
    double P_right;
    double P_up;
    double P_down;
    //Parameter for width of gaussian potential well (manually set the width of the well in the initialization loop)
    double sigma_strained;
    //Parameter for depth(amplitude) of gaussian potential well (manually set in the initialization loop)
    double amplitude;

    //Total force and total force componenets for probability calculations
    double F_net;
    double F_net_x;
    double F_net_y;
};

//Define struct to store variances along x and y
struct variance{
    double x_variance_struct;
    double y_variance_struct;
};
/*
//initialize functions
double bivariate_gaussian(double x, double y);
void spawn_exciton(double probability, int x, int y);
Exciton decay_chance(Exciton exciton);


Exciton get_radii(Exciton exciton);
variance calculate_variance(variance variance_total);

*/

int randomNum1_4(void);
Exciton move_exciton(int directionNum, Exciton exciton);
int weightedRandomNum1_4(double P_right, double P_up, double P_left, double P_down);


int main(){
    /*
    //CREATE FOLDERS FOR THE SIMULATION OUTPUT
    // Get current date and time
    std::time_t t = std::time(nullptr);
    char date_time[100];
    std::strftime(date_time, sizeof(date_time), "%Y-%m-%d %H:%M:%S", std::localtime(&t));

    // Create directory path with unique name
    string positons_path = "/Users/david/Desktop/C++/Exciton Research/Heat Map R/" + string(date_time) + string(" Positons");
    string variance_path = "/Users/david/Desktop/C++/Exciton Research/Heat Map R/" + string(date_time) + string(" Variance");

    // Check if the directory already exists or not
    struct stat st;
    if (stat(positons_path.c_str(), &st) == 0) {
        cout << "Error: Positions directory already exists \n";
    } else {
        // Create position data directory
        int status = mkdir(positons_path.c_str(), S_IRWXU | S_IRWXG | S_IRWXO);
        if (status == 0) {
            cout << "Directory created successfully at " << positons_path << "\n";
        } else {
            cout << "Error creating directory: " << strerror(errno) << "\n";
        }
    }
    //Check if directory exists or not
    if (stat(variance_path.c_str(), &st) == 0) {
        cout << "Error: Variance directory already exists \n";
    } else {
        // Create variance data directory
        int status = mkdir(variance_path.c_str(), S_IRWXU | S_IRWXG | S_IRWXO);
        if (status == 0) {
            cout << "Directory created successfully at " << variance_path << "\n";
        } else {
            cout << "Error creating directory: " << strerror(errno) << "\n";
        }
    }
    */

//TILE SIDELENGTH = 20nm
//initialize the cell grid
cell grid[Nx][Ny];

vector<cell> strained_tiles;

//Cycle through every point on the grid (INITIALIZATION LOOP) this loop runs only once
for (int i = 0; i < Nx; i++) {
    for (int j = 0; j < Ny; j++) {
        //Grid points take the form (i,j) and we're assigning numerical values to the ordered pairs stored in the matrix
        grid[i][j].x = i;
        grid[i][j].y = j;
        grid[i][j].strained = false; // Default: unstrained tile
        
        // Manually set strained regions
        if (i == 20 && j == 40) {
            grid[i][j].strained = true;
            //Set width of potential well
            grid[i][j].sigma_strained = 7;
            //Set depth of the potential well (1 is default)
            grid[i][j].amplitude = 1;

            strained_tiles.push_back(grid[i][j]);

            //Instantiate test exciton(s) [I put it in this so that the exciton is only instantiated once, not a very clean way to code, David]
            Exciton test_exciton1(20,30,true,"George");

            //Add the exciton to the list of active (not decayed) excitons
            active_Excitons.push_back(test_exciton1);
        }
        if (i == 20 && j == 20) {
            grid[i][j].strained = true;
            grid[i][j].sigma_strained = 7;
            grid[i][j].amplitude = 1;
            strained_tiles.push_back(grid[i][j]);
        }
        
    }   
}

//Do the strained calculations for each tile on the grid
for (int i = 0; i < Nx; i++) {
    for (int j = 0; j < Ny; j++) {
        //Calculate the force applied on the tile by all strained regions
        for (int q = 0; q < strained_tiles.size(); q++) {
            double xDiff = strained_tiles.at(q).x - grid[i][j].x;
            double yDiff = strained_tiles.at(q).y - grid[i][j].y;
            double radius_strain = sqrt(((xDiff * xDiff) + (yDiff * yDiff)));

            //Calculate force experienced by excitons on the tile by strained_tile(q)

            double force_gaussian_exponent = -( (radius_strain * radius_strain) / (2 * strained_tiles.at(q).sigma_strained * strained_tiles.at(q).sigma_strained)); 


            double Force_Strained_q = K_sA*strained_tiles.at(q).amplitude*(pow(2.71828, force_gaussian_exponent));


            //Calculate components of force
            double F_x = Force_Strained_q*(xDiff/radius_strain);
            double F_y = Force_Strained_q*(yDiff/radius_strain);

            //Add net force and net force components to the struct elements of that tile
            grid[i][j].F_net += Force_Strained_q;
            grid[i][j].F_net_x += F_x;
            grid[i][j].F_net_y += F_y;

            
        }
        //Calculate the probability of exciton motion from total force on the tile from all strained regions
        double Force_normalizer = abs(grid[i][j].F_net_x) + abs(grid[i][j].F_net_y);

        if (grid[i][j].F_net_x < 0){

                //Calculate probability of exciton moving left on this tile (normalized by denominator)
                grid[i][j].P_left = (1 - grid[i][j].F_net_x)/(4 + Force_normalizer);
                grid[i][j].P_right = 1/(4 + Force_normalizer);
            }

            if (grid[i][j].F_net_x >= 0){

                //Calculate probability of exciton moving left on this tile (normalized by denominator)
                grid[i][j].P_right = (1 + grid[i][j].F_net_x)/(4 + Force_normalizer);
                grid[i][j].P_left = 1/(4 + Force_normalizer);
            }

            if (grid[i][j].F_net_y < 0){

                //Calculate probability of exciton moving down on this tile (normalized by denominator)
                grid[i][j].P_down = (1 - grid[i][j].F_net_y)/(4 + Force_normalizer);
                grid[i][j].P_up = 1/(4 + Force_normalizer);
            }

            if (grid[i][j].F_net_y >= 0){

                //Calculate probability of exciton moving down on this tile (normalized by denominator)
                grid[i][j].P_up = (1 + grid[i][j].F_net_y)/(4 + Force_normalizer);
                grid[i][j].P_down = 1/(4 + Force_normalizer);
            }




    }
}



//MAIN LOOP (590 cycles = 1 nanosecond, 885 cycles = 1.5ns)
int j=0;
while (j<100){
    //Get the total # of living excitons
    int exciton_population_size = active_Excitons.size();

    for (int i = 0; i < exciton_population_size; i++) {
        if (active_Excitons.at(i).active){

            //Determine which way the exciton will move based on probabiilities associated with the tile it's on
                //Instead of grid[i][j] I'm getting the coordinates of the exciton's X and Y positions since those will match that of the tile it's on and putting that into the [i][j] arguments
            int Movement_direction = weightedRandomNum1_4(grid[active_Excitons.at(i).X_pos][active_Excitons.at(i).Y_pos].P_right, 
            grid[active_Excitons.at(i).X_pos][active_Excitons.at(i).Y_pos].P_up, grid[active_Excitons.at(i).X_pos][active_Excitons.at(i).Y_pos].P_left,
            grid[active_Excitons.at(i).X_pos][active_Excitons.at(i).Y_pos].P_down);

            //Move the exciton's position on the grid
            active_Excitons.at(i) = move_exciton(Movement_direction, active_Excitons.at(i));

            cout<<"Geoge moved to: ("<<active_Excitons.at(i).X_pos<<", "<<active_Excitons.at(i).Y_pos<<")"<<endl;
        }
    }
    j++;


}

}


//Generate a random integer between 1 and 4
int randomNum1_4(void){
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<int> dist(1, 4);
    return dist(mt);
}


Exciton move_exciton(int directionNum, Exciton exciton){
    //returns an error if the random number used to pick a direction is not between 1 and 4 or not an integer
    //Commented out for efficiency
    // if (directionNum != 1 && directionNum != 2 && directionNum != 3 && directionNum != 4){
    //     cout<<"Error: Did not recieve a direction \n";
    // }
    if (directionNum==1){
        exciton.X_pos += 1;
        //Check to make sure exciton is inside the grid
        if (exciton.X_pos < Nx && exciton.X_pos > 0 && exciton.Y_pos < Ny && exciton.Y_pos > 0){
            return exciton;
        }
        //If exciton is not in grid, delete it
        else {
            exciton.active = false;
            exciton.fate = "Out of bounds, deletion";
            return exciton;
        }

    }
    else if (directionNum==2){
        exciton.Y_pos+=1;
        //Check to make sure exciton is inside the grid
        if (exciton.X_pos < Nx && exciton.X_pos > 0 && exciton.Y_pos < Ny && exciton.Y_pos > 0){
            return exciton;
        }
        //If exciton is not in grid, delete it
        else {
            exciton.active = false;
            exciton.fate = "Out of bounds, deletion";
            return exciton;
        }
    }
    else if (directionNum==3){
        exciton.X_pos-=1;
        //Check to make sure exciton is inside the grid
        if (exciton.X_pos < Nx && exciton.X_pos > 0 && exciton.Y_pos < Ny && exciton.Y_pos > 0){
            return exciton;
        }
        //If exciton is not in grid, delete it
        else {
            exciton.active = false;
            exciton.fate = "Out of bounds, deletion";
            return exciton;
        }
    }
    else if (directionNum==4){
        exciton.Y_pos-=1;
        //Check to make sure exciton is inside the grid
        if (exciton.X_pos < Nx && exciton.X_pos > 0 && exciton.Y_pos < Ny && exciton.Y_pos > 0){
            return exciton;
        }
        //If exciton is not in grid, delete it
        else {
            exciton.active = false;
            exciton.fate = "Out of bounds, deletion";
            return exciton;
        }
    }
    cout<<"move_exciton function failed to return after movemenet, check for bugs.\n";
    return exciton;
}

int weightedRandomNum1_4(double P_right, double P_up, double P_left, double P_down){
    std::random_device rd;
    std::mt19937 rngw(rd());
    std::vector<double> weights;
    weights.clear();
    weights.push_back(P_right);
    weights.push_back(P_up);
    weights.push_back(P_left);
    weights.push_back(P_down);

    std::discrete_distribution<> dist(weights.begin(), weights.end());

    int result = dist(rngw) +1;

    return result;
}




/*
double total = grid[25][49].P_left + grid[25][49].P_right + grid[25][49].P_up + grid[25][49].P_down;

cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has F_net of "<<grid[25][49].force<<endl;
cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has F_x of "<<grid[25][49].F_x<<endl;
cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has F_y of "<<grid[25][49].F_y<<endl;

cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has P_left of "<<grid[25][49].P_left<<endl;
cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has P_right of "<<grid[25][49].P_right<<endl;
cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has P_up of "<<grid[25][49].P_up<<endl;
cout<<"Tile: ("<<grid[23][41].x<<", "<<grid[23][41].y<<") has P_down of "<<grid[25][49].P_down<<endl;


//So clearly there is an issue regarding the way I've gotten the force components
cout<<"Sum of probabilities: "<<total<<endl;

*/


/*
for (int i=0; i<20; i++){
//RANDOM EXCITON MOTION

cout<<"("<<active_Excitons.at(0).X_pos<<", "<<active_Excitons.at(0).Y_pos<<") \n";
int random_move_num = randomNum1_4();
active_Excitons.at(0) = move_exciton(random_move_num, active_Excitons.at(0));
}
*/
